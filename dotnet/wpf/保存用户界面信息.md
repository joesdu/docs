> 在 WPF 等用户客户端程序的开发过程中,往往我们为了良好的用户体验,需要保存用户的界面信息.比如用户针对界面部分的 UI 变化,如放大窗体,UI 中部分元素位置的编辑.当下一次用户打开的时候能够还原之前的编辑结果.若是每次打开都恢复到默认设置那可真的是无法接受,今天就来分享一下我在 WPF 中是如何利用 LiteDB 实现的.

本文分如下几个部分来说明:(基于之前的 WpfAutoDISample 在其基础上来添加和修改)

- 调整主界面的 UI 布局,使用我们自定义的界面分割组件 StatefulGridSplitter,从名字就可以看出来,他也需要保存状态.
- 在 WPF 项目中使用 IMessenger 来传递一些消息(早期的开发中,使用发布订阅模式自己实现了一个,后来发现 CommunityToolkit.Mvvm 中有现成的就用现成得了 😅).
- 如何使用 LiteDB 来保存我们的界面信息.

#### 自定义 StatefulGridSplitter 组件

> 为了后期的持久化以及更多的功能设置,这里我们需要自己来实现一个简易的 GridSplitter 组件,而不是使用默认的.

```csharp
public sealed class StatefulGridSplitter : GridSplitter;
```

上面的代码就可以实现基本的 GridSplitter 功能,但是可以看出来他和默认的效果一样 😂.不用着急,后面再一点点的添加内容.

- 为了使其能够实现水平和垂直方向都能正常工作,我们还需在 App.xaml 中添加资源.资源内容如下.

```xml
<ResourceDictionary>
    <Style TargetType="uc:StatefulGridSplitter">
        <Setter Property="HorizontalAlignment" Value="Stretch" />
        <Setter Property="Template">
            <Setter.Value>
                <ControlTemplate TargetType="uc:StatefulGridSplitter">
                    <Border Background="{TemplateBinding Background}" CornerRadius="1" />
                </ControlTemplate>
            </Setter.Value>
        </Setter>
    </Style>
</ResourceDictionary>
```

- 到这里我们的分割组件就基本完成,接下来就去调整一下 MainWindow.xaml 实现一个常见的 UI 布局.

```xml
<Window x:Class="WpfAutoDISample.Views.MainWindow"
                 xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
                 xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                 xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
                 xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
                 xmlns:viewModels="clr-namespace:WpfAutoDISample.ViewModels"
                 xmlns:uc="clr-namespace:WpfAutoDISample.Controls"
                 d:DataContext="{d:DesignInstance viewModels:MainWindowModel}"
                 mc:Ignorable="d"
                 Title="MainWindow" Height="600" Width="800"
                 WindowStartupLocation="CenterScreen">
    <Grid Background="Transparent">
        <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="*" />
            </Grid.ColumnDefinitions>
            <!-- 左侧的Panel -->
            <Border Grid.Column="0">
                <ListView BorderThickness="0"
                       SelectedIndex="0"
                       TextOptions.TextFormattingMode="Display"
                       TextOptions.TextRenderingMode="ClearType"
                       VirtualizingStackPanel.IsVirtualizing="True"
                       VirtualizingStackPanel.VirtualizationMode="Recycling"
                       RenderOptions.ClearTypeHint="Enabled">
                    <ListViewItem>1</ListViewItem>
                    <ListViewItem>2</ListViewItem>
                </ListView>
                <!--ItemContainerStyle="{StaticResource ListViewItemStyle}"-->
            </Border>
            <!-- GridSplitter用于调整大小 -->
            <uc:StatefulGridSplitter Grid.Column="1" Width="3" />
            <!-- 右侧的Panel -->
            <Border Grid.Column="2" HorizontalAlignment="Stretch">
                <Grid>
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*" />
                        <RowDefinition Height="Auto" />
                        <RowDefinition Height="*" />
                    </Grid.RowDefinitions>
                    <!-- 上侧的Panel -->
                    <Border Grid.Row="0" Background="Beige">
                        <TextBlock>上侧的Panel</TextBlock>
                    </Border>
                    <uc:StatefulGridSplitter Grid.Row="1" Height="3" />
                    <!-- 下侧的Panel -->
                    <Border Grid.Row="2" Background="Bisque">
                        <TextBlock>下侧的Panel</TextBlock>
                    </Border>
                </Grid>
            </Border>
    </Grid>
</Window>

```

从上面的代码分析就可以得到我们的 UI 大概是左右分割,然后右侧再上下分割一下,在左侧我们放入了一个 ListView 用来显示一个列表,右侧则使用两个 TextBlock 分别来代指显示内容,为了省事,这里就不截图了.

- 同样还有个知识点可以顺带说一下.可以看到我的 ListView 设置了一些属性,这些属性的作用主要是为了防止界面渲染的时候出现文字虚化的问题.暂时就不详细说明各个配置的含义了,感兴趣的可以自行 Bing 一下.

```csharp
TextOptions.TextFormattingMode="Display"
TextOptions.TextRenderingMode="ClearType"
VirtualizingStackPanel.IsVirtualizing="True"
VirtualizingStackPanel.VirtualizationMode="Recycling"
RenderOptions.ClearTypeHint="Enabled"
```

至此,UI 的基本内容就搞定,但是暂时并不会持久化界面信息.接下来我们就来实现这些功能.

#### 发布订阅 UI 变化消息

> 在持久化 UI 之前,我们还需要利用消息系统,发布和订阅相关的 UI 变化的消息,如窗体大小和位置的改变,GridSplitter 的位置变化.以及其他想保存的一些 UI 信息.

- 在 WPF 中我们可以利用 CommunityToolkit.Mvvm 中的 `WeakReferenceMessenger`, `IMessenger` 来实现消息的订阅和发布.
- 我们先来实现简单的内容,将主窗体的大小变化通过 IMessenger 发送给我们的 StatefulGridSplitter,让其可以根据窗体大小来计算最大拖动范围,避免拖到界面之外造成显示问题.
- 首先定义我们的消息体:

```csharp
internal sealed class MainWindowSizeChangeEventArgs(double width, double height) : EventArgs
{
    public double Width { get; } = width;

    public double Height { get; } = height;
}
```

- 然后我们在 MainWindow.xaml.cs 的构造函数中注册 SizeChanged 事件,并完成消息发布的代码.

```csharp
public MainWindow(MainWindowViewModel mwv, ILogger<MainWindow> logger, IMessenger messenger)
{
    InitializeComponent();
    DataContext = mwv;
    _logger = logger;
    _messenger = messenger;
    SizeChanged += MainWindow_SizeChanged;
}

private void MainWindow_SizeChanged(object sender, SizeChangedEventArgs e)
{
    // 获取当前窗体的尺寸
    var width = ActualWidth;
    var height = ActualHeight;
    _logger.LogInformation("MainWindow size changed: Width={Width}, Height={Height}", width, height);
    // 发布事件并传递尺寸信息
    _messenger.Send(new MainWindowSizeChangeEventArgs(width, height));
}
```

- 消息发送出去后,那么我们就可以在 StatefulGridSplitter 组件中订阅该消息,并完成我们的逻辑代码.

```csharp
public sealed class StatefulGridSplitter : GridSplitter, IDisposable
{
    private readonly IMessenger _messenger;
    private bool _disposed;

    public StatefulGridSplitter()
    {
        // 设置默认背景色
        Background = new SolidColorBrush(Color.FromRgb(99, 99, 99));
        _messenger = App.Services.GetRequiredService<IMessenger>();
        _messenger.Register<StatefulGridSplitter, MainWindowSizeChangeEventArgs>(this, Handler);
    }

    /// <summary>
    /// 用来表示GridSplitter的最小范围,为了不让Grid拖动到不可见区域,默认为0.1
    /// </summary>
    public required double MinRatio { get; set; } = 0.1;

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private void Handler(object recipient, MainWindowSizeChangeEventArgs message)
    {
        if (Parent is not Grid parentGrid) return;
        // 获取GridSplitter的当前列和行位置
        var columnIndex = Grid.GetColumn(this);
        var rowIndex = Grid.GetRow(this);
        var orientation = DetermineOrientation();
        if (orientation == GridSplitterOrientation.Vertical)
        {
            // 当为垂直方向时，当前列索引即为控制的列索引
            parentGrid.ColumnDefinitions[columnIndex - 1].MinWidth = message.Width * MinRatio;
            parentGrid.ColumnDefinitions[columnIndex + 1].MinWidth = message.Width * MinRatio;
            parentGrid.ColumnDefinitions[columnIndex - 1].MaxWidth = message.Width * (1 - MinRatio);
            parentGrid.ColumnDefinitions[columnIndex + 1].MaxWidth = message.Width * (1 - MinRatio);
        }
        else
        {
            // 当为水平方向时，当前行索引即为控制的列索引
            parentGrid.RowDefinitions[rowIndex - 1].MinHeight = message.Height * MinRatio;
            parentGrid.RowDefinitions[rowIndex + 1].MinHeight = message.Height * MinRatio;
            parentGrid.RowDefinitions[rowIndex - 1].MaxHeight = message.Height * (1 - MinRatio);
            parentGrid.RowDefinitions[rowIndex + 1].MaxHeight = message.Height * (1 - MinRatio);
        }
    }

    private void Dispose(bool disposing)
    {
        if (_disposed) return;
        if (disposing)
        {
            _messenger.Unregister<MainWindowSizeChangeEventArgs>(this);
        }

        // 释放非托管资源（如果有）
        _disposed = true;
    }

    ~StatefulGridSplitter()
    {
        Dispose(false);
    }
}
```

从上面的代码中我们即可在主窗体发生变化后,发送消息到我们的组件,并根据变化的值来动态的调整 GridSplitter 的位置和限制范围.不过我们的最小范围也可以通过属性传入,只需要在使用的时候指定就行.

```xml
<uc:StatefulGridSplitter MinRatio="0.12" Grid.Column="1" Width="3" />
```
